// utils/rag-pipeline/vector-store-search.ts
import { createPool } from '@vercel/postgres';
import OpenAI from 'openai';

// Initialize OpenAI client
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// Embedding model to use
const EMBEDDING_MODEL = 'text-embedding-ada-002';
const EMBEDDING_DIMENSION = 1536; // Dimensionality of text-embedding-ada-002

// Initialize Postgres pool
const poolConfig = {
  connectionString: process.env.DATABASE_URL || process.env.POSTGRES_URL,
};
const pool = createPool(poolConfig);

/**
 * Generates an embedding for the given text using OpenAI's API
 * @param text - The text to generate an embedding for
 * @returns A vector of floats representing the embedding
 */
export async function generateEmbedding(text: string): Promise<number[]> {
  try {
    const response = await openai.embeddings.create({
      model: EMBEDDING_MODEL,
      input: text,
    });
    
    return response.data[0].embedding;
  } catch (error) {
    console.error('Error generating embedding:', error);
    throw error;
  }
}

/**
 * Represents a chunk of text with its URL and optional metadata
 */
export interface TextChunk {
  url: string;
  text: string;
  created_at?: Date;
}

/**
 * Searches the vector store for chunks similar to the query embedding
 * @param queryEmbedding - The embedding vector for the query
 * @param options - Search options like topK (number of results)
 * @returns Array of text chunks sorted by similarity
 */
export async function searchVectorStore(
  queryEmbedding: number[],
  options: { topK: number } = { topK: 3 }
): Promise<TextChunk[]> {
  try {
    if (!queryEmbedding || queryEmbedding.length !== EMBEDDING_DIMENSION) {
      throw new Error(`Invalid embedding: expected ${EMBEDDING_DIMENSION} dimensions`);
    }

    // Convert embedding to the format expected by pgvector: '[1,2,3,...]'
    const embeddingString = `[${queryEmbedding.join(',')}]`;
    
    // Query the database for similar chunks using L2 distance (Euclidean)
    const { rows } = await pool.query(
      `SELECT url, chunk_text as text, created_at,
       embedding <-> $1::vector as distance
       FROM knowledge_base_chunks
       ORDER BY distance
       LIMIT $2`,
      [embeddingString, options.topK]
    );
    
    return rows.map(row => ({
      url: row.url,
      text: row.text,
      created_at: row.created_at
    }));
  } catch (error) {
    console.error('Error searching vector store:', error);
    throw error;
  }
}

/**
 * Utility function to generate embedding for a query and search in one step
 * @param query - The user query to search for
 * @param options - Search options like topK
 * @returns Array of text chunks sorted by similarity
 */
export async function queryVectorStore(
  query: string,
  options: { topK: number } = { topK: 3 }
): Promise<TextChunk[]> {
  const embedding = await generateEmbedding(query);
  return searchVectorStore(embedding, options);
}
